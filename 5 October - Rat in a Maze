import java.util.*;

class Solution {
    public ArrayList<String> ratInMaze(int[][] maze) {
        ArrayList<String> result = new ArrayList<>();
        int n = maze.length;
        
        // If starting cell or destination is blocked, no path possible
        if (maze[0][0] == 0 || maze[n-1][n-1] == 0) return result;

        boolean[][] visited = new boolean[n][n];
        
        // Start backtracking from (0,0)
        solve(0, 0, maze, n, visited, "", result);
        
        Collections.sort(result); // sort lexicographically
        return result;
    }
    
    private void solve(int i, int j, int[][] maze, int n, boolean[][] visited, String path, ArrayList<String> result) {
        // If reached destination
        if (i == n-1 && j == n-1) {
            result.add(path);
            return;
        }
        
        // Mark current cell visited
        visited[i][j] = true;
        
        // Directions: D, L, R, U (for lexicographic order: "D L R U")
        // Move Down
        if (isSafe(i+1, j, maze, n, visited)) {
            solve(i+1, j, maze, n, visited, path + "D", result);
        }
        // Move Left
        if (isSafe(i, j-1, maze, n, visited)) {
            solve(i, j-1, maze, n, visited, path + "L", result);
        }
        // Move Right
        if (isSafe(i, j+1, maze, n, visited)) {
            solve(i, j+1, maze, n, visited, path + "R", result);
        }
        // Move Up
        if (isSafe(i-1, j, maze, n, visited)) {
            solve(i-1, j, maze, n, visited, path + "U", result);
        }
        
        // Backtrack (unmark cell)
        visited[i][j] = false;
    }
    
    private boolean isSafe(int i, int j, int[][] maze, int n, boolean[][] visited) {
        return (i >= 0 && j >= 0 && i < n && j < n && maze[i][j] == 1 && !visited[i][j]);
    }
}
