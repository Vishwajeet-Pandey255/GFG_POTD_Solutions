class Solution {
    public ArrayList<Integer> safeNodes(int V, int[][] edges) {

        // make adjacency (original) + reverse adjacency
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        ArrayList<ArrayList<Integer>> rev = new ArrayList<>();
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<>());
            rev.add(new ArrayList<>());
        }
        
        int[] outDeg = new int[V];   // outdegree count
        
        for(int[] e: edges){
            int u = e[0];
            int v = e[1];
            adj.get(u).add(v);
            rev.get(v).add(u);     // reverse edge
            outDeg[u]++;           // outdegree
        }
        
        // queue for BFS â†’ push all terminal nodes first
        Queue<Integer> q = new LinkedList<>();
        for(int i=0;i<V;i++){
            if(outDeg[i] == 0){
                q.add(i);
            }
        }
        
        boolean[] safe = new boolean[V];
        
        while(!q.isEmpty()){
            int node = q.poll();
            safe[node] = true;
            
            // check reverse graph neighbors
            for(int prev: rev.get(node)){
                outDeg[prev]--;
                if(outDeg[prev] == 0){
                    q.add(prev);
                }
            }
        }
        
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i=0;i<V;i++){
            if(safe[i]) ans.add(i);
        }
        
        return ans;
    }
}
