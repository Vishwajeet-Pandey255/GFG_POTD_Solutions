class Solution {

    static class Edge {
        int u, v, w;
        Edge(int u, int v, int w){
            this.u = u;
            this.v = v;
            this.w = w;
        }
    }

    static class DSU {
        int parent[], rank[];
        DSU(int n){
            parent = new int[n];
            rank = new int[n];
            for(int i=0;i<n;i++) parent[i] = i;
        }

        int find(int x){
            if(parent[x] == x) return x;
            return parent[x] = find(parent[x]);
        }

        boolean union(int a, int b){
            a = find(a);
            b = find(b);
            if(a == b) return false;

            if(rank[a] < rank[b]) parent[a] = b;
            else if(rank[b] < rank[a]) parent[b] = a;
            else {
                parent[b] = a;
                rank[a]++;
            }
            return true;
        }
    }

    public int secondMST(int V, int[][] edges) {
        int E = edges.length;

        // Convert edges into objects
        List<Edge> all = new ArrayList<>();
        for(int i=0;i<E;i++)
            all.add(new Edge(edges[i][0], edges[i][1], edges[i][2]));

        // Sort by weights
        all.sort((a,b) -> a.w - b.w);

        // Build MST using Kruskal
        DSU dsu = new DSU(V);
        boolean[] used = new boolean[E];
        int mstWeight = 0, count = 0;

        for(int i=0;i<E;i++){
            Edge e = all.get(i);
            if(dsu.union(e.u, e.v)){
                used[i] = true;
                mstWeight += e.w;
                count++;
            }
        }

        // If MST doesn't exist
        if(count != V-1) return -1;

        int secondBest = Integer.MAX_VALUE;

        // Try removing each MST edge and replace it with a non-MST edge
        for(int i=0;i<E;i++){
            if(!used[i]) continue; // only consider MST edges

            DSU d = new DSU(V);
            int weight = 0;
            int cnt = 0;

            // Rebuild MST but skip the i-th MST edge
            for(int j=0;j<E;j++){
                if(j == i) continue;

                Edge e = all.get(j);
                if(d.union(e.u, e.v)){
                    weight += e.w;
                    cnt++;
                }
            }

            if(cnt == V-1 && weight > mstWeight){ 
                secondBest = Math.min(secondBest, weight);
            }
        }

        return (secondBest == Integer.MAX_VALUE) ? -1 : secondBest;
    }
}
