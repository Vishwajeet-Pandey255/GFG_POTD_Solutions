import java.util.*;

class Solution {
    // Function to find the diameter of the graph
    public int diameter(int V, int[][] edges) {
        // Step 1: Create adjacency list
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            adj.get(edge[0]).add(edge[1]);
            adj.get(edge[1]).add(edge[0]);
        }

        // Step 2: Run BFS from any node (say node 0)
        int farthestNode = bfs(0, adj, V)[0];

        // Step 3: Run BFS again from the farthest node found in step 2
        int[] result = bfs(farthestNode, adj, V);
        int diameter = result[1]; // The distance to the farthest node is the diameter

        return diameter;
    }

    // Helper function for BFS that returns {farthestNode, distance}
    private int[] bfs(int start, List<List<Integer>> adj, int V) {
        boolean[] visited = new boolean[V];
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{start, 0});
        visited[start] = true;

        int farthestNode = start;
        int maxDist = 0;

        while (!q.isEmpty()) {
            int[] node = q.poll();
            int curr = node[0];
            int dist = node[1];

            if (dist > maxDist) {
                maxDist = dist;
                farthestNode = curr;
            }

            for (int neighbor : adj.get(curr)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.offer(new int[]{neighbor, dist + 1});
                }
            }
        }

        return new int[]{farthestNode, maxDist};
    }
}
