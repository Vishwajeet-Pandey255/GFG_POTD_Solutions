class Solution {
    public int chocolatePickup(int[][] mat) {
        int n = mat.length;
        if (n == 0) return 0;
        // If start or end blocked -> no path
        if (mat[0][0] == -1 || mat[n-1][n-1] == -1) return 0;

        final int NEG = Integer.MIN_VALUE / 4; // safe negative
        // prev[r1][r2] = best value for given t-1 with persons at (r1, c1) and (r2, c2)
        int[][] prev = new int[n][n];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                prev[i][j] = NEG;

        prev[0][0] = mat[0][0];

        int maxT = 2 * (n - 1);
        for (int t = 1; t <= maxT; ++t) {
            int[][] curr = new int[n][n];
            for (int i = 0; i < n; ++i)
                for (int j = 0; j < n; ++j)
                    curr[i][j] = NEG;

            // r1 ranges so that c1 = t - r1 is inside [0,n-1]
            int r1min = Math.max(0, t - (n - 1));
            int r1max = Math.min(n - 1, t);
            for (int r1 = r1min; r1 <= r1max; ++r1) {
                int c1 = t - r1;
                if (c1 < 0 || c1 >= n) continue;
                if (mat[r1][c1] == -1) continue;

                int r2min = r1min;
                int r2max = r1max;
                for (int r2 = r2min; r2 <= r2max; ++r2) {
                    int c2 = t - r2;
                    if (c2 < 0 || c2 >= n) continue;
                    if (mat[r2][c2] == -1) continue;

                    // value collected at these two positions (don't double count if same)
                    int val = mat[r1][c1];
                    if (r1 != r2 || c1 != c2) val += mat[r2][c2];

                    int bestPrev = NEG;
                    // four possibilities from previous step (t-1):
                    // (r1, r2)   <- both moved right (c1-1, c2-1)
                    if (r1 <= n-1 && r2 <= n-1) bestPrev = Math.max(bestPrev, prev[r1][r2]);
                    // (r1-1, r2) <- first moved down, second moved right
                    if (r1 - 1 >= 0) bestPrev = Math.max(bestPrev, prev[r1 - 1][r2]);
                    // (r1, r2-1) <- first moved right, second moved down
                    if (r2 - 1 >= 0) bestPrev = Math.max(bestPrev, prev[r1][r2 - 1]);
                    // (r1-1, r2-1) <- both moved down
                    if (r1 - 1 >= 0 && r2 - 1 >= 0) bestPrev = Math.max(bestPrev, prev[r1 - 1][r2 - 1]);

                    if (bestPrev > NEG) {
                        curr[r1][r2] = Math.max(curr[r1][r2], bestPrev + val);
                    }
                }
            }
            prev = curr; // move to next time step
        }

        int ans = prev[n - 1][n - 1];
        return Math.max(0, ans);
    }
}
